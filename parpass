#!/bin/bash
#
# parpass.sh
#
# Version:    1.3.0
# History:    2020-06-14, 2020-07-11, 2023-11-15, 2023-11-19
#
# Project Description:
#
# Reads the password file /etc/passwd, searches for user names beginning with $1,
# and parses the record to print it in a human-readable form on the screen.
#
# Author:     Bernd Storck
# Contact:    https://www.facebook.com/BStLinux/
#
# Copyright:  2023, Bernd Storck
# License:    GNU General Public License 3.0

# Daten zur Selbstbeschreibung des Scripts: ...............
readonly ORIGINAL_SCRIPT_NAME="parpass"
readonly CURRENT_SCRIPT_NAME="${0##*/}"  ## Name of the script file
readonly TITLE="$SCRIPT (parsePasswd)"
readonly VERSION="1.3.0"
readonly VERSIONS_TIME_STAMP="2023-11-19 17:25:34"  # date +"%Y-%m-%d %T"


# Farbnamensvariablen: ....................................
readonly WHITE='\e[0;37m'
readonly YELLOW_BOLD='\e[1;33m'
readonly GREEN_BOLD='\e[1;32m'
readonly COLOROFF='\e[0m'

OLDIFS="$IFS"
IFS=":"

readonly language_file_name="parpass.lang.${LANG:0:2}"

for config_path in "$HOME/parpass/" "$HOME/" "/etc/parpass/" "/etc/" "./"; do
  language_file="${config_path}$language_file_name"
  if [ -f "$language_file" ]; then
    source "${language_file}"
    file_found=true
    break
  fi
done

if ! "$file_found" ; then
  UILANG="English"
  label_ID="IDs (uid/gid)"
  label_homeDir="Directory"
  label_loginShell="Login Shell"
  label_realName="Real Name"
  label_room="Room"
  label_workPhone="Work Fon"
  label_phone="Home Phone"
  label_comment="Comment"
fi

# Functions: -----------------------------------------

usage () {
# Displays program purpose and usage help.

echo -e "${YELLOW_BOLD}$TITLE $VERSION ${COLOROFF}\n"

if [ "$UILANG" = "Deutsch" ]; then
  echo -e "Das Programm liest die Passwortdatei \"/etc/passwd\" und zeigt ihren Inhalt gut lesbar an.

AUFRUFPARAMETER:
  --help|-h|--hilf   # Diese Hilfe anzeigen
  --version|-V       # Die Version dieses Installationsskripts anzeigen.
  --full_version     # Eine ausfÃ¼hrliche Versionsinformation anzeigen.

BEISPIELAUFRUFE:
  ${GREEN_BOLD}Aufruf            Beschreibung${COLOROFF}

  $CURRENT_SCRIPT_NAME root   # Zeigt die Daten aus der passwd zum Account root an.
  $CURRENT_SCRIPT_NAME bs     # Zeigt die Daten zu allen Accounts an, die mit \"bs\" beginnen.
  $CURRENT_SCRIPT_NAME        # Zeigt die Daten aus der Datei passwd zu allen Accounts an.
"
else  # English help:
  echo -e "Reads the password file \"/etc/passwd\" and displays its content human-readable on the screen.

PARAMETERS:
  --help|-h|--hilf   # Display this help.
  --version|-V       # Display the script version.
  --full_version     # Display detailed version information.

EXAMPLES:
  ${GREEN_BOLD}Call              Description${COLOROFF}

  $CURRENT_SCRIPT_NAME root   # Shows information from passwd according to the account. \"root\".
  $CURRENT_SCRIPT_NAME bs     # Shows information about all accounts, which do begin with \"bs\".
  $CURRENT_SCRIPT_NAME        # Shows information from file \"passwd\" for all accounts.\n"
fi
}


print_program_identification () {
# Gibt die vollstaendige Programmselbstbezeichnung aus.
  printf "\n${WHITE}%s (%s, %s, %s)${COLOROFF}\n\n" \
  "$PROG_NAME" "$ORIGINAL_SCRIPT_NAME" "$VERSION" "$VERSIONS_TIME_STAMP"
}


normalize_option () {
# Wenn eine Option mehr als einen Buchstaben hat, korrigiert diese Funktion
# beispielsweise '-examples' zu '--examples'.
#
# Zudem wandelt sie mehrbuchstabige Optionen in Kleinbuchstaben um.
#
  local input="$1"
  local output="$input"

  if [[ ! "$1" =~ ^[a-zA-Z0-9] ]]; then
    input="$input"
    # Prueft mit bash-internen Kommandos, ob die Option mit nur genau einem '-'
    # beginnt und darauf mindestens zwei Buchtaben folgen und ersetzt
    # gegebenenfalls das '-' am Anfang durch '--':
    if [[ $input =~ ^-([a-zA-Z]{2,}) ]]; then
      output="--${BASH_REMATCH[1]}"
      output="${output,,}"  # Converts to lower case.
    fi
  fi
  echo "$output"
}


printField() {
# Pairs of field names and their content are written to a temporary file,
# allowing the result to be reformatted at the end once it is complete.
  echo -e "\t\e[1;37m${2}:\e[0m# ${1}" >> /tmp/parpass.tmp
}


printNotEmpty() {
  if [ "$1" != "" ]; then
    printField "$1" "$2"
  fi
}


# Main: ----------------------------------------------

option=$(normalize_option "$1")
case "$option" in
  --help|-h|--hilf|-help)
    usage
    exit 0
    ;;
  --version|-V)
    printf "%s (Version %s)\n" "$ORIGINAL_SCRIPT_NAME" "$VERSION"
    exit 0
    ;;
  --fullversion|--id|--identifi[ck]ation)
    print_program_identification
    exit 0
    ;;
  -\#)  # Versionsnummer anzeigen
    echo "$VERSION"
    exit 0
    ;;
  *)
    unset option
    ;;
esac

rm -f /tmp/parpass.tmp

while read -r user trash uid gid data homeDir loginShell; do
  if grep -i -q "^$1" <<< "$user" > /dev/null 2>&1; then
    echo -e "\n\e[1;93m${user} \e[0;33m------------------------------------------------\e[0m";
    printField "$uid / $gid" "$label_ID"
    printField "$homeDir" "$label_homeDir"
    printField "$loginShell" "$label_loginShell"

    IFS=','
    read -r realName room workPhone phone comment <<< "$data"

    printNotEmpty "$realName" "$label_realName"
    printNotEmpty "$room" "$label_room"
    printNotEmpty "$workPhone" "$label_workPhone"
    printNotEmpty "$phone" "$label_phone"
    printNotEmpty "$comment" "$label_comment"
    IFS=':'
    column -s# -t /tmp/parpass.tmp
    rm /tmp/parpass.tmp
  fi
done < "/etc/passwd"

IFS="$OLDIFS"

exit 0
